# 注意
　以下のドキュメントは部分的かつ暫定的なものです。
# 概要
　構文が埋め込まれた文字列から新たな文字列を生成し、それを配列に列挙して返します。
# 導入
```javascript
import strings from './strings.js';
```
# 構文
```javascript
const parsed = strings(string[, assigned]);
```
# 引数
## string
　型 string を示す値。値内に所定の演算子や式を文字列として任意に埋め込むことができます。
## assigned
　引数 *string* に埋め込んだ構文から参照することのできる値をプロパティにした Object を指定します。[Nullish](https://developer.mozilla.org/ja/docs/Glossary/Nullish) ではない object 以外の型を示す値を指定した場合、その値は新規に作成された Object からシンボル StringsExpression.anonAssignKey で指定した値を参照できるプロパティが作成されます。未指定の場合、空の Object が既定値として使われます。
# 戻り値
　指定に基づいて生成された文字列を列挙した Array を返します。引数 *string* に構文が存在しない場合、引数 *string* を唯一の要素にした Array を返します。
# strings の構文
　引数 *string* には、特定の演算子を埋め込むことができます。演算子に使われる記号を通常の文字列として使う場合は、対象の記号をエスケープすることができます。
## `\\` エスケープ
　演算子をエスケープするには、二重バックスラッシュ `\\` をエスケープシーケンスとして使います。演算子は一対の括弧で表されますが、エスケープする際は、以下のようにいずれか片方の括弧の直前に `\\` を置けば、構文と認識されなくなります。仮に、このエスケープシーケンスを文字列として使いたい場合は、エスケープシーケンスをエスケープします。
```javascript
console.log(
	strings("[:1+1]"),      // [ "2" ]
	strings("[:1+1\\]"),    // [ "[:1+1]" ]
	strings("\\[:1+1]"),    // [ "[:1+1]" ]
	strings("\\[:1+1\\]"),  // [ "[:1+1]" ]
	strings("\\\\[:1+1]")   // [ "\\2" ]
);
```
## 式
　関数演算子などに指定する引数中では式を使えます。式中にはリテラルや演算子、識別子を指定できます。また任意の数のホワイトスペースやタブも使えますが、評価時にそれらは無視されます。
```javascript
console.log(strings("[:	1 +1 ]")); // [ "2" ]
```
　strings では式中での以下の演算子や識別子をサポートします。

|演算の優先順位|対象|
|--:|:--|
|1|グループ化演算子 `( ... )`|
|2|カンマ演算子 `,`、識別子、リテラル、再帰演算子 `< ... >`、評価演算子 `` ` ... ` ``、参照演算子 `$[ ... ]`、関数演算子 `[ ... ]`|
|3|除算演算子 `/`|
|4|乗算演算子 `*`|
|5|減算演算子 `-`|
|6|加算演算子 `+`|

```javascript
console.log(strings("[:(8, 1 + (0 + 1)) * 2 / 4 - -1]")); // [ "2" ]
```
### リテラル
　以下のリテラルは、評価時に対応する JavaScript のリテラルに変換されます。

#### 文字列
　文字列は引用符 `'` で囲みます。JavaScript と違い、二重引用符 `"` は使えません。このことから、引数 *string* に指定する文字列は、`"` で囲むことが推奨されます。`'` で囲む場合は、*string* 中で文字列を囲う `'` はすべてバックスラッシュ `\` でエスケープする必要があります。
```javascript
console.log(
	strings("[:'いろは']"), // [ "いろは" ]
	strings('[:\'いろは\']') // [ "いろは" ]
);
```
#### 数値
　数値は十進法表記のみ対応しており、小数点や負の値、`Infinity`、`NaN` を指定することができます。
```javascript
console.log(strings("[:Infinity * -0.1]")); // [ "-Infinity" ]
```
#### 論理
　true に相当する `shin`、false に相当する `gi` が使えます。`true`、`false` もエイリアスとして使えます。
```javascript
console.log(
	strings("[:shin]"), // [ "true" ]
	strings("[:true]")  // [ "true" ]
);
```
#### null
　null に相当する `nai` が使えます。`null` もエイリアスとして使えます。

#### undefined
　undefined に相当する `hu` が使えます。`undefined` もエイリアスとして使えます。

#### 正規表現
　JavaScript と同じように、正規表現はスラッシュ `/` で囲みます。[フラグ](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags)を設定する場合は、正規表現を `/` で閉じた直後に任意の文字を指定します。正規表現内でスラッシュ `/` を文字として使う場合のみ、JavaScript とは異なり、二重バックスラッシュ `\\\\` でエスケープします。
```javascript
console.log(
	strings("[:/abc/i]"),                                 // [ "/abc/i" ]
	strings("[@: 'replace', 'a/B/c', /[\\/bc]/gi, 'a' ]") // [ "aaaaa" ]
);
```

### 識別子
　識別子は式中に限り使うことができます。[JavaScript の識別子](https://developer.mozilla.org/ja/docs/Glossary/Identifier)に準じ、必ずアルファベットを含む文字か、記号 `$` `_` で始まり、それに続く文字列では数字を含めることができます。アルファベットの大文字小文字は区別されます。

　識別子は、strings の第二引数 *assigned* のプロパティ名を示します。後述する参照演算子 `$[]` の実質的なショートハンドとも言い換えられます。ただし、`$[]` では、それが文字列であれば、どんな名前のプロパティも参照できますが、識別子は参照できるプロパティに上記のような文字列上の制限があると言う違いがあります。

```javascript
console.log(
	
	strings("[:sample + 1]",    { sample: 1 }),  // [ "2" ] 識別子による参照
	strings("[:$[sample] + 1]", { sample: 1 }),  // [ "2" ] 参照演算子 $[] による参照,
	
	strings("[:0a + 1]",        { '0a': 1 }),    // SyntaxError
	strings("[:$[0a] + 1]",     { '0a': 1 })     // [ "2" ]
	
	strings("[:handler(shin) + 1]",   { handler: v => +v }), // [ "2" ]
	// assigned のプロパティに関数を設定すれば、その実行もできる。
	strings("[:handler args + 1]",    { handler: v => +v, args: [ true ] }), // [ "2" ]
	// グループ化演算子と引数は、内部では同様に配列に変換される。
	// この式は妥当には見えないかもしれないが、実行上の矛盾はなく、現状では許容される。
	
);
```

## `< ... >` 再帰演算子
　文字列を `<` `>` で囲むと、その内側の文字列を新たな引数にして strings を再帰します。再帰中でも引数 *assigned* のプロパティは参照できます。この演算子は引数を含めた任意の場所で使えますが、引数にする際は、式に他の値や演算子を付けず、単一の値として指定する必要があります。
```javascript
console.log(
	strings("<あ>"), // [ "あ" ]
	strings("あ")    // [ "あ" ]
);
// 他の構文の引数として指定しない場合、処理内容は表面化しない。
```
## `` ` ... ` `` 評価演算子
　文字列を `` ` `` で囲むと、その内側の文字列を JavaScript のコードとして実行します。コードには、strings の第二引数 *assigned* が、第一引数に *assigned* として与えられます。

　戻り値は、コード内の return 文が返す値です。値の評価は状況に応じて変化し、他の演算子や値とともに引数の式に指定した場合は、いったん内部形式の値に変換されたあと、改めて評価されます。この時、値がリテラル以外の型で、型 object であればシンタックスエラーになります。一方、Array.isArray で真を示せば、その配列を、要素間をカンマ演算子で区切るグループ化演算子と認識し、その末尾の値を使おうとします（実際の処理では、要素の値は既に JavaScript によって評価済みであることを前提として、単にその配列の末尾の値を取得します）。配列に要素が存在しない場合、値は反映されません。引数に他の演算子や値を伴わない単一の値として、または引数以外の場所で指定した場合、戻り値はそのままの形で strings の戻り値に反映されます。この JavaScript 形式の値がどのように評価されるかもまた指定状況の仕様に準じます。以上のように、評価演算子は任意の場所で使え、再帰演算子と異なり式に組み込むこともできると言う特徴も持ちます。
```javascript
console.log(
	
	strings("`return 1 + 1;`"),                      // [ "2" ]
	strings("`return assigned.v`", { v: 1 + 1 }),    // [ "2" ]
	// コードは関数 eval で実行されるのではなく、新規に Function を作って実行するため、
	// 戻り値を使うには常に return を記述する必要がある。
	
	strings(`${1 + 1}`),                             // [ "2" ]
	// 最初の例のように、引数を使わないコードであれば、
	// JavaScript のテンプレートリテラルを使った方が簡潔に書ける。
	
	strings(`\`return assigned.v;\``, { v: 1 + 1 }), // [ "2" ]
	// テンプレートリテラルの中で評価演算子を使うには、単一のバックスラッシュで演算子記号 ` をエスケープする。
	// この場合、開始、終了のいずれの記号もエスケープする必要がある点に注意。
	
	strings("[:`return [ 0, 1, 2 ];`]"),             // [ "0", "1", "2" ]
	// 仕様の変更により、以下の例は再現されない。現在は [ "0,1,23" ] になるが、より蓋然性の高い結果への変更を検討中。
	strings("[:`return [ 0, 1, 2 ];` + 3]")          // [ "5" ]
	// 上の例は戻り値を [ 0, 1, 2 ]、下の例は (0, 1, 2) として扱っている。
	// strings 内部ではグループ化演算子を通常の配列と隔てられた状態で配列として扱っているが、
	// コードからの戻り値時点ではその区別を付けられない。
	// JavaScript 上では配列全体を式に組み込めない性質を利用して、
	// 戻り値の配列が式内に位置していればグループ化演算子、そうでなければ配列として振舞っている。
	
);
```
## `$[ ... ]` 参照演算子
　文字列を `$[` `]` で囲むと、その内側の文字列全体を第二引数 *assigned* のプロパティ名として、その名前のプロパティが存在していれば、その値で置換します。括弧内の文字列は空白も含めすべてプロパティ名として扱われる点に注意してください。文字列に一致する名前のプロパティが存在しない場合の値は undefined で、それがそのまま評価されれば空の文字列になります。参照演算子は評価演算子同様、任意の場所で使えます。

　空の文字列を指定すると、strings の第二引数 *assigned* に型 object 以外の値を指定した際に、その値で作成されるプロパティを取得できます。
```javascript
console.log(
	strings("$[sample]", { sample: 0 }), // [ '0' ]
	strings("$[サンプル]"), // [ '' ]
	strings("$[]", 0) // [ '0' ]
);
```
## `[ ... ]` 関数演算子
　`[` `]` で囲まれた文字列は、定義された関数のパラメーターとして使われ、その実行結果を基に文字列を生成します。
### パラメーターの構造とパターン
+ [関数名=プロパティ名:オプション:引数]
+ [関数名:オプション:引数]
+ [関数名:引数]

　パラメーターは左からヘッダー部、オプション部、ボディー部の三つに大別されます。この内、オプション部は省略可能です。各部はそれぞれコロン `:` ないしセミコロン `;` で隔てられますが、`;` はヘッダー部とそれ以外を隔てる時にのみ使用できます。後述しますが、`;` で隔てた際は、`:` で隔てた時とは挙動が変化する点にも注意してください。

### ヘッダー部
　ヘッダー部には関数名を指定します。関数名に続けて代入記号 `=` と、その後に任意の文字列を指定すると、その文字列を strings の第二引数 *assigned* のプロパティ名として、関数の実行結果を、その値として保存します。これら各要素間の空白は許容されかつ解析時には無視されます。

　ヘッダー部と他の部を隔てる記号は、通常は `:` を指定しますが、`;` を指定すると、関数の実行結果の戻り値への反映を抑制します。つまり、関数の実行結果はそのままでは戻り値に含まれません。抑制された出力は、参照演算子 `$[ ... ]` や、式中の識別子を通じて、他の関数処理などに反映させることができます。
```javascript
console.log(
	
	strings("[:0]"),               // [ "0" ]
	strings("[;0]"),               // [ "" ]
	// ヘッダー部をセミコロン ; で区切ると、出力は抑制される。
	
	strings("[=muted;0]$[muted]"), // [ "0" ]
	// 抑制した出力は、参照演算子や識別子を通じて任意の場所で利用できる。
	
	strings("[=;0]$[]")	        // [ "0" ]
	// プロパティ名を指定しない場合、暗黙的にプロパティ StringsExpression.anonAssignKey の値に設定される。
	// このプロパティは $[] を通じて参照する。
	
);
```
　実際のところ、関数演算子には、ひとつ以上の `:` ないし `;` が必須で、関数演算子の最小構成は `[]` ではなく、`[:]` になります。

　`:` `;` 以外に `!` も指定できます。`!` を指定すると、その演算子内の指定は代入記号 `=` の指定も含めて一切戻り値に反映されません。この挙動を利用して、一時的に指定を無効化したり、コメントとして関数演算子を埋め込むことができます。

```javascript
console.log(strings(
	"[=曜日名!'火','金']$[曜日名]曜日は可燃ゴミの日です。"), // [ '曜日は可燃ゴミの日です。' ]
	"[=曜日名;'火','金']$[曜日名]曜日は可燃ゴミの日です。") // [ '火曜日は可燃ゴミの日です。', '金曜日は可燃ゴミの日です。' ]
);
```

### オプション部
　ヘッダー部とボディー部の間には任意でオプション部を設定できます。オプション部は、ヘッダー部の区切り文字（`:`, `;`）のあとに記述し、ボディー部との間は常に `:` で隔てます。オプション部には任意の数のオプションを指定します。

　オプションは、関数の戻り値を操作します。オプションの指定方法は二通りあり、引数を伴わないオプションはオプション名を文字列で指定、引数を伴う際は、オプション名に続けてグループ化演算子 `( ... )` を使って引数を指定します。引数間はカンマ演算子 `,` で区切ります。オプション間はホワイトスペースかタブで区切ります。

　オプションは現状では以下のものを指定できます。

#### `dup([counts][, separator])`
　関数の戻り値を第一引数 *counts* で指定した回数だけ複製します。*counts* には非負整数を指定します。負の値を指定した場合は 0 に、非数値を指定した場合は 1 が使われます。第二引数 *separator* に任意の文字列を指定すると、複製した戻り値の間に separator を挟みます。このオプションは、関数 `^` と同等です。複製したい値が任意の関数の戻り値に限定される場合、このオプションを使った方が明示的になります。

　関数 `^` も同様ですが、*counts* に安易に大きな数値を指定すると、戻り値によってはコンピューターのリソースを消費し尽くす点に注意してください。戻り値の大きさは、関数の実行結果の要素数を *counts* でべき乗すると事前に確かめられます。
```javascript
console.log(
	
	strings("[:dup(3, '・'): 'い', 'ろ', 'は']"),
	// この関数の戻り値は、オプションなしだと三つの文字列 [ "い", "ろ", "は" ] を生成する。
	// 上記のオプションを付けると、すべての要素をそれぞれ三回繰り返すため、
	// 3 ^ 3 で、全 27 通りの文字列を生成することになる。
	
	strings("[: 'い', 'ろ', 'は']・[: 'い', 'ろ', 'は']・[: 'い', 'ろ', 'は']")
	// 同じ戻り値を得られる構文を dup を使わずに記述すると上記のようになる。
	
);
```

### ボディー部
　ボディー部には、関数に与える引数を指定します。引数が複数ある場合は、引数間をカンマ演算子 `,` で区切ります。

## 関数
　名前にエイリアスを持っている関数は、その中の任意の名前を使うことができます。

### ` `, `I` 評価関数
```
[(,I):[arg0][, arg1][, ...]]
```
　関数名を未指定にするか、`I` を指定すると、評価関数を実行します。評価関数は引数に与えられた式を単に評価し、その値を戻り値にします。引数は任意の数指定でき、それぞれの引数はそのまま戻り値として返される配列の要素になります。
```javascript
console.log(strings("[:0, 0 + 1, 1 + 1][:3 * 1, 2 * 2, 5 / 1]"));
// [ '03', '04', '05', '13', '14', '15','23', '24', '25' ]
```

### `+`, `cnt` カウント関数
```
[(+,cnt):[from = 0][, to = 1][, value = 1][, pad = 0][, padString = ' ']]
```
　第一引数 *from* に第三引数 *value* を、第二引数 *to* に達するまで加算し続け、その過程のすべての文字列を返します。第四引数 *pad* に任意の整数を指定すると、生成した文字列の文字数を指定した値で切り詰めるか、足りなければ第六引数 padString に指定した値で補います。

　*pad* に指定する値で、字詰めの結果が変化します。正の整数を指定した場合、文字列の先頭方向を切り詰めるか補います。負の整数を指定した場合、末尾方向を切り詰めるか補います。

　*from* か *to* に文字列を指定した場合、*from*、*to* は文字列として扱われ、*value* はその文字のコードポイントに *to* に達するまで加算されます。

　*to* は *from* より小さい値にすることもできます。この場合、*from* に、*value* の値を *to* に達するまで減算し続けた戻り値になります。

　*value* に負の値を指定すると特殊な動作になり、*from* + *value* の値が *to* に達した時、それが *to* と一致せずに超過していれば、通常は戻り値に含まれないその超過した値を、*to* の値に丸めて戻り値に加えます。言い換えれば、*value* に負の値を指定すると、*value* がどんな値であっても、戻り値の終端は常に *to* になります。
　
### `^`, `dup` 複製関数
```
[(^,dup):strings[, counts = 1][, separator = '']]
```
　第三引数 *strings* の値で strings を再帰して実行し、その結果を第一引数 *counts* の数だけ複製します。第二引数 *separator* に任意の文字列を指定すると、複製間に *separator* を挟み込ませます。

### `@`, `app` 呼び出し関数
```
[(@,app):functionName = 'toString'[, thisArgument = internalLastValues][, argumentsList]]
```
　第二引数 *thisArgument* が持つ、第一引数 *functionName* に指定した名前のメソッドを実行し、その戻り値を基に文字列を生成します。メソッドに引数を与えるには、その値を第三引数 *argumentsList* に指定した配列に列挙します。

　*thisArgument* に Nullish の値を指定すると、この関数演算子が他の関数演算子の補助関数群に指定されていれば、元の関数の戻り値も含む直近の戻り値の要素をその値にします。これは、もしこの関数が単体で、あるいは先頭で実行された場合、何も処理が行われないことを意味します。Nullish 以外の値を指定した場合は、直近の戻り値の数だけ、*thisArgument* が持つメソッド *functionName* を指定に従って機械的に繰り返し実行します。

　現状では、実行時に補助関数群を指定する方法が存在しないので、*string* 内でこの関数を使うことは想定していません。この関数は、カウント関数 `^` で、文字列の切り詰め、補完機能を実現するのに内部で使用しています。内部的にはカウント関数はカウント機能しか持ちません。内部でカウント関数の補助関数を作成し、カウント関数が生成した文字列をこの関数を通じて、`String.prototype.padStart` や `String.prototype.padEnd` にバイパスしています。

```javascript
console.log(
	strings("[@: 'padStart', '1', 3, '0']")), // [ '001' ]
	strings("001")                            // [ '001' ]
)
```

### `@@`, `apps` イテレーター呼び出し関数
```
[(@@,apps):functionName= 'toString', iterableObject[, argumentsList]]
```
　第二引数 *iterableObject* に与えられた[反復可能オブジェクト](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Iterators_and_Generators#iterables)が持つ[イテレーター](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Iterators_and_Generators#iterators)が返す要素を、第一引数 *functionName* に指定した名前のメソッドを実行、その戻り値を基に文字列を生成します。メソッドに引数を与えるには、その値を第三引数 *argumentsList* に指定した配列に列挙します。

　呼び出し関数と似ていますが、戻り値の作成はイテレーターが返す要素に依存し、他の関数による戻り値の暗黙的な再利用を行ないません。この関数は、*string* で使うことを想定していますが、現状では *string* に文字列以外の反復可能オブジェクトを直接指定する方法が存在しないため、参照演算子 `$[ ... ]` や識別子を通じて *assigned* のプロパティに指定された反復可能オブジェクトを使うなど、間接的に指定する必要があります。

　イテレーターの呼び出しは再帰しません。*iterableObject* に文字列を指定すると、文字列のイテレーターが呼び出されますが、文字列を要素にした配列を指定しても、呼び出されるのは配列のイテレーターだけです。

```javascript
console.log(
	strings("[+=v;0,2,1][@@: 'padStart', v, 3, '0']")), // [ '000', '001', '002' ]
	strings("[@@: 'padStart', '012', 3, '0']")),        // [ '000', '001', '002' ]
	// 文字列は String.prototype[@@iterator] を持つ。
)
```

### `dl`, `fetch` ダウンロード関数
```
[(dl,fetch):url[, type = 'text' ]]
```

### `dlt`, `fetchtext` テキストファイルダウンロード関数
```
[(dlt,fetchtext):url[, replaced ][, replacer = '' ]]
```

### `$`, `dom` セレクター関数
```
[($,dom):url, selector[, propertyName = 'innerHTML' ][, replaced ][, replacer = '' ]]
```
　第一引数 *url* に指定した値が示す HTML 文書から、第二引数 *selector* が示す [CSS セレクター](https://developer.mozilla.org/ja/docs/Web/CSS/CSS_Selectors) に一致する要素をすべて取得し、それらの要素の、第三引数 *propertyName* に指定した属性ないしプロパティの値を取得します。*url* が URL を示す値であれば、これらの処理は非同期通信で行なわれます。URL は、[CORS](https://developer.mozilla.org/ja/docs/Glossary/CORS) が可能でない限り、[同一オリジン](https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy)である必要があります。またこの時 `strings` が返す値も Promise になります。この Promise は、一連の処理を終えたあとに、`strings` の本来の戻り値で解決されます。*url* が [Falsy](https://developer.mozilla.org/ja/docs/Glossary/Falsy) の場合、上記の処理は `strings` の実行元となるドキュメントに対して同期処理で行なわれます。この時、`strings` の戻り値は、通常通り、生成された文字列を列挙する Array になります。

　平たく言えば、外部のウェブページから情報を取得するための関数ですが、上記の通り、CORS を無視することはできません。また、*url* に有効な URL を指定した場合の動作はかなり特殊で、取得したドキュメントは、[\<iframe\>](https://developer.mozilla.org/ja/docs/Web/HTML/Element/iframe) を使って、実行元のコンテキストで一度展開されます。展開後、\<iframe\> は情報を取得次第直ちにドキュメントから削除されますが、ウェブページ上に一瞬でもそれが表示されるのは避けられません。この表示は、視覚効果としても好意的な印象を生むことは決してないでしょう。

　また、それよりも重要かつ重大な点として、上記のように、取得した文書はスクリプトの実行元で展開されるため、文書に相対パスが含まれる場合、その相対パスが正しく解決されなくなります。取得した文書が、実行元と同一パス上にあるか、あるいはその相対パスが偶然実行元からも解決できる場合を除けば、取得した文書内からの相対パスによるリソースの取得は失敗に終わるでしょう。この問題は、取得した文書が、外部の JavaScript などを通じて動的に情報を読み込む場合に深刻化します。相対パスによって読み込まれる外部のスクリプトが動作せず、セレクターが示す要素がページ上に現われないと言うケースが考えられます。それでなくても、ウェブページとの対話によって得られる情報は、この関数からは一切取得できません。

　機能だけを見れば、外部の情報のスクレイピングに使うことしか考えられない関数ですが、実際には、同一オリジン内の、外部のリソースに依存しない静的な HTML 文書内の情報の取得と言う、現代のウェブにおけるニッチな状況でしかこの関数が正常に機能することはありません。

　第四引数 *replaced* と第五引数 *replacer* を指定すると、取得した情報に文字列置換処理を行うことができます。この処理は `String.prototype.replace` を通じて行われるため、*replaced* には[正規表現リテラル](#正規表現)を指定することができます。同様に、*replacer* 内に[置換パターン](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E5%BC%95%E6%95%B0%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%81%AE%E6%8C%87%E5%AE%9A)を指定できます。

<!--# 0 と 1 の 8 次元座標
```javascript
console.log(...strings("[^:8,',',<[+:0,1,1]>]")); // その1
console.log(...strings("[+:dup(8,','):0,1,1]")); // その2
```-->