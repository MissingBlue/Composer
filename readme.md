# 注意
　以下のドキュメントは部分的かつ暫定的なものです。
# 概要
　所定の構文が埋め込まれた文字列から新たな文字列を生成し、それを配列に列挙して返します。
# 導入
```javascript
import strings from './strings.js';
```
# 構文
```javascript
const parsed = strings(string[, assigned]);
```
# 引数
## string
　型 string を示す値。値内に所定の構文を文字列として任意に埋め込むことができます。
## assigned
　引数 *string* に埋め込んだ構文から参照することのできる値をプロパティにした Object を指定します。Nullish ではない object 以外の型を示す値を指定した場合、その値は新規に作成された Object からシンボル StringsExpression.anonAssignKey で指定した値を参照できるプロパティが作成されます。未指定の場合、空の Object が既定値として使われます。
# 戻り値
　指定に基づいて生成された文字列を列挙した Array を返します。引数 *string* に構文が存在しない場合、引数 *string* を唯一の要素にした Array を返します。
# strings の構文
　引数 *string* には、特定の演算子を埋め込むことができます。演算子に使われる記号を通常の文字列として使う場合は、対象の記号をエスケープすることができます。
## エスケープ
　構文をエスケープするには、二重バックスラッシュ **\\\\** をエスケープシーケンスとして使います。構文は一対の括弧で表されますが、エスケープする際は、以下のようにいずれか片方の括弧の直前に \\\\ を置けば、構文と認識されなくなります。仮に、このエスケープシーケンスを文字列として使いたい場合は、エスケープシーケンスをエスケープします。
```javascript
console.log(
	strings("[:1+1]"),      // [ "2" ]
	strings("[:1+1\\]"),    // [ "[:1+1]" ]
	strings("\\[:1+1]"),    // [ "[:1+1]" ]
	strings("\\[:1+1\\]"),  // [ "[:1+1]" ]
	strings("\\\\[:1+1]")   // [ "\\2" ]
);
```
## 再帰演算子 < ... >
　文字列を **< >** で囲むと、その内側の文字列を新たな引数にして strings を再帰します。再帰中でも引数 *assigned* のプロパティは参照できます。この演算子は引数を含めた任意の場所で使えますが、引数にする際は、式に他の値や演算子を付けず、単一の値として指定する必要があります。
```javascript
console.log(
	strings("<あ>"), // [ "あ" ]
	strings("あ")    // [ "あ" ]
);
// 他の構文の引数として指定しない場合、処理内容は表面化しない。
```
## 評価演算子 \` ... \`
　文字列を **\`** で囲むと、その内側の文字列を JavaScript のコードとして実行します。コードには、strings の第二引数 *assigned* が、第一引数に *assigned* として与えられます。戻り値は、Array 以外の場合は、値が持つメソッド prototype.toString を通じて文字列に変換します。戻り値が Array の場合は変換されませんが、その要素は文字列に変換されます。要素の変換は再帰しません。評価演算子は任意の場所で使え、再帰演算子と異なり式にも組み込めます。
```javascript
console.log(
	strings("`return 1 + 1;`"),                     // [ "2" ]
	strings("`return assigned.v`", { v: 1 + 1 })    // [ "2" ]
	// コードは関数 eval で実行されるのではなく、新規に Function を作って実行するため、
	// 戻り値を使うには常に return を記述する必要がある。
	strings(`${1 + 1}`)                             // [ "2" ]
	// 最初の例のように、引数を使わないコードであれば、
	// JavaScript のテンプレートリテラルを使った方が簡潔に書ける。
	strings(`\`return assigned.v;\``, { v: 1 + 1 }) // [ "2" ]
	// テンプレートリテラルの中で評価演算子を使うには、単一のバックスラッシュで演算子記号 ` をエスケープする。
	// この場合、開始、終了のいずれの記号もエスケープする必要がある点に注意。
);
```
## 参照演算子 $[ ... ]
　文字列を **$[ ]** で囲むと、その内側の文字列全体を第二引数 *assigned* のプロパティ名として、その名前のプロパティが存在していれば、その値で置換します。括弧内の文字列は空白も含めすべてプロパティ名として扱われる点に注意してください。文字列に一致する名前のプロパティが存在しない場合の値は undefined で、それがそのまま評価されれば空の文字列になります。参照演算子は評価演算子同様、任意の場所で使えます。

　空の文字列を指定すると、strings の第二引数 *assigned* に型 object 以外の値を指定した際に、その値で作成されるプロパティを取得できます。
```javascript
console.log(
	strings("$[sample]", { sample: 0 }), // [ '0' ]
	strings("$[サンプル]"), // [ '' ]
	strings("$[]", 0) // [ '0' ]
);
```
## 関数演算子 [ ... ]
　引数 string 内の [ ] で囲まれた文字列は、定義された関数のパラメーターとして使われ、その実行結果を基に文字列を生成します。
### パラメーターの構造とパターン
+ 関数名=プロパティ名:オプション:引数
+ 関数名:オプション:引数
+ 関数名:引数

　構文中では、任意の数の半角スペースやタブの使用が許容され、それらは戻り値に影響および反映しません。パラメーターはコロン : によって区切られます。パラメーターの左端の区間は常に関数名を示します。関数名のあとに任意で代入記号 = と、それに続く JavaScript の識別子で定義された文字で構成された文字列を指定すると、strings の第二引数 assigned に、その関数の戻り値を値とするプロパティを作成します。このプロパティは後述の参照構文 * ... * や、その他の方法で参照できます。この関数名区間に続く区間との間の区切り文字にコロン : ではなくセミコロン ; を指定すると、この関数の戻り値は、生成される文字列への反映を抑制されます。関数は実行されますが、その戻り値は、assigned を通じて他の場所で参照されない限り、strings の戻り値に使われないと言うことです。

　任意に指定できるオプション区間では、定義された戻り値に影響を加えるオプションを指定します。オプションは、単一の文字列や、そのオプションに与える引数を ( ... ) で囲んで続けて指定します。引数が複数指定できる場合はそれぞれをコンマ , で区切ります。

　関数名区間ないしオプション区間に続く引数区間でも同様に各引数間はコンマ , で区切ります。

　引数は、原則として式として評価されます。式は値の型判定と四則演算、assigned 内のプロパティ名を示す識別子の使用に対応しています。値に使える型は string, number, boolean, undefined に対応しており、他に null 相当の値も指定できます。string はシングルクォーテーションで ' で囲みます。引数に string を与える場合、strings の第一引数 string に与える文字列はダブルクォーテーション " で囲むことが推奨されます。でなければ、引数の文字列を囲むシングルクォーテーション ' は、通常の JavaScript の仕様に則って単一のバックスラッシュ \\ でエスケープする必要があります。number は十進法表記にのみ対応します。

　boolean は true を shin、false を gi で表します。これらは true, false をそれぞれ日本語にした真、偽に由来します。undefined は hu、null は nai で、これらも日本語に由来します。こうした命名は興味本位以上の理由を持たないため、変更の可能性は常に存在します。（hu は、「不」に由来しますが、fu の方が打ち易く、日本語話者には直感的かもしれません。ここでは if と区別し易くするため hu にしています）

　上記の仕様を持つ式を評価する過程で、関数 eval などの JavaScript 内部の構文解析を経ない点に留意してください。strings では実装されていない JavaScript 上の仕様を式に含めると、シンタックスエラーを起こします。

　式が演算子を含まない、単一の値であれば、その値に再帰構文や Array などの任意の型の値を指定できます。ただし、それらを引数として想定した関数に与えないと、シンタックスエラーを起こすでしょう。

<!--# 0 と 1 の 8 次元座標
```javascript
console.log(...strings("[^:8,',',<[+:0,1,1]>]")); // その1
console.log(...strings("[+:echo(8,','):0,1,1]")); // その2
```-->