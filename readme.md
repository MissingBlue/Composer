# 注意
　以下のドキュメントは部分的かつ暫定的なものです。
# 概要
　構文が埋め込まれた文字列から新たな文字列を生成し、それを配列に列挙して返します。
# 導入
```javascript
import strings from './strings.js';
```
# 構文
```javascript
const parsed = strings(string[, assigned]);
```
# 引数
## string
　型 string を示す値。値内に所定の演算子や式を文字列として任意に埋め込むことができます。
## assigned
　引数 *string* に埋め込んだ構文から参照することのできる値をプロパティにした Object を指定します。[Nullish](https://developer.mozilla.org/ja/docs/Glossary/Nullish) ではない object 以外の型を示す値を指定した場合、その値は新規に作成された Object からシンボル StringsExpression.anonAssignKey で指定した値を参照できるプロパティが作成されます。未指定の場合、空の Object が既定値として使われます。
# 戻り値
　指定に基づいて生成された文字列を列挙した Array を返します。引数 *string* に構文が存在しない場合、引数 *string* を唯一の要素にした Array を返します。
# strings の構文
　引数 *string* には、特定の演算子を埋め込むことができます。演算子に使われる記号を通常の文字列として使う場合は、対象の記号をエスケープすることができます。
## `\\` エスケープ
　演算子をエスケープするには、二重バックスラッシュ `\\` をエスケープシーケンスとして使います。演算子は一対の括弧で表されますが、エスケープする際は、以下のようにいずれか片方の括弧の直前に `\\` を置けば、構文と認識されなくなります。仮に、このエスケープシーケンスを文字列として使いたい場合は、エスケープシーケンスをエスケープします。
```javascript
console.log(
	strings("[:1+1]"),      // [ "2" ]
	strings("[:1+1\\]"),    // [ "[:1+1]" ]
	strings("\\[:1+1]"),    // [ "[:1+1]" ]
	strings("\\[:1+1\\]"),  // [ "[:1+1]" ]
	strings("\\\\[:1+1]")   // [ "\\2" ]
);
```
## 式
　関数演算子などに指定する引数中では式を使えます。式中には演算子や識別子、キーワードを指定できます。また任意の数のホワイトスペースやタブも使えますが、評価時にそれらは無視されます。
```javascript
console.log(strings("[:	1 +1 ]")); // [ "2" ]
```
　strings では式中での以下の演算子や識別子をサポートします。

|演算の優先順位|対象|
|--:|:--|
|1|グループ化演算子 `( ... )`|
|2|識別子、キーワード、再帰演算子 `< ... >`、評価演算子 `` ` ... ` ``、参照演算子 `$[ ... ]`、関数演算子 `[ ... ]`|
|3|カンマ演算子 `,`|
|4|除算演算子 `/`|
|5|乗算演算子 `*`|
|6|減算演算子 `-`|
|7|加算演算子 `+`|

```javascript
console.log(strings("[:(8, 1 + (0 + 1)) * 2 / 4 - 1]")); // [ "0" ]
```

### 識別子
　識別子は式中に限り使うことができます。[JavaScript の識別子](https://developer.mozilla.org/ja/docs/Glossary/Identifier)に準じ、必ずアルファベットを含む文字か、記号 `$` `_` で始まり、それに続く文字列では数字を含めることができます。アルファベットの大文字小文字は区別されます。

　識別子は、strings の第二引数 *assigned* のプロパティ名を示します。後述する参照演算子 `$[]` の実質的なショートハンドとも言い換えられます。ただし、`$[]` では、それが文字列であれば、どんな名前のプロパティも参照できますが、識別子は参照できるプロパティに上記のような文字列上の制限があると言う違いがあります。

```javascript
console.log(
	
	strings("[:sample + 1]",    { sample: 1 }),  // [ "2" ] 識別子による参照
	strings("[:$[sample] + 1]", { sample: 1 }),  // [ "2" ] 参照演算子 $[] による参照,
	
	strings("[:0a + 1]",        { '0a': 1 }),    // SyntaxError
	strings("[:$[0a] + 1]",     { '0a': 1 })     // [ "2" ]
	
	strings("[:handler(shin) + 1]",   { handler: v => v && 1}), // [ "2" ]
	// assigned のプロパティに関数を設定すれば、その実行もできる。
	strings("[:handler args + 1]",    { handler: v => v && 1, args: [ true ] }), // [ "2" ]
	// この式は妥当には見えないが、実行上の矛盾はなく、現状では許容される。
	
);
```

### キーワード
　式中では値として定義されたキーワードを使えます。キーワードは評価時に対応する JavaScript の値に置換されます。

|キーワード|JavaScript 値|エイリアス|
|:--:|:--|:--|
|nai|null|null|
|hu|undefined|undefined|
|shin|true|true|
|gi|false|false|

```javascript
console.log(
	strings("[:shin]"), // [ "true" ]
	strings("[:true]")  // [ "true" ]
);
```

## `< ... >` 再帰演算子
　文字列を `<` `>` で囲むと、その内側の文字列を新たな引数にして strings を再帰します。再帰中でも引数 *assigned* のプロパティは参照できます。この演算子は引数を含めた任意の場所で使えますが、引数にする際は、式に他の値や演算子を付けず、単一の値として指定する必要があります。
```javascript
console.log(
	strings("<あ>"), // [ "あ" ]
	strings("あ")    // [ "あ" ]
);
// 他の構文の引数として指定しない場合、処理内容は表面化しない。
```
## `` ` ... ` `` 評価演算子
　文字列を `` ` `` で囲むと、その内側の文字列を JavaScript のコードとして実行します。コードには、strings の第二引数 *assigned* が、第一引数に *assigned* として与えられます。

　戻り値は、コード内の return 文が返す値です。値の評価は状況に応じて変化し、他の演算子や値とともに引数の式に指定した場合は、いったん内部形式の値に変換されたあと、改めて評価されます。この時、値がリテラル以外の型で、型 object であればシンタックスエラーになります。一方、Array.isArray で真を示せば、その配列を、要素間をカンマ演算子で区切るグループ化演算子と認識し、その末尾の値を使おうとします（実際の処理では、要素の値は既に JavaScript によって評価済みであることを前提として、単にその配列の末尾の値を取得します）。配列に要素が存在しない場合、値は反映されません。引数に他の演算子や値を伴わない単一の値として、または引数以外の場所で指定した場合、戻り値はそのままの形で strings の戻り値に反映されます。この JavaScript 形式の値がどのように評価されるかもまた指定状況の仕様に準じます。以上のように、評価演算子は任意の場所で使え、再帰演算子と異なり式に組み込むこともできると言う特徴も持ちます。
```javascript
console.log(
	
	strings("`return 1 + 1;`"),                      // [ "2" ]
	strings("`return assigned.v`", { v: 1 + 1 }),    // [ "2" ]
	// コードは関数 eval で実行されるのではなく、新規に Function を作って実行するため、
	// 戻り値を使うには常に return を記述する必要がある。
	
	strings(`${1 + 1}`),                             // [ "2" ]
	// 最初の例のように、引数を使わないコードであれば、
	// JavaScript のテンプレートリテラルを使った方が簡潔に書ける。
	
	strings(`\`return assigned.v;\``, { v: 1 + 1 }), // [ "2" ]
	// テンプレートリテラルの中で評価演算子を使うには、単一のバックスラッシュで演算子記号 ` をエスケープする。
	// この場合、開始、終了のいずれの記号もエスケープする必要がある点に注意。
	
	strings("[:`return [ 0, 1, 2 ];`]"),             // [ "0", "1", "2" ]
	strings("[:`return [ 0, 1, 2 ];` + 3]")          // [ "5" ]
	// 上の例は戻り値を [ 0, 1, 2 ]、下の例は (0, 1, 2) として扱っている。
	// strings 内部ではグループ化演算子を通常の配列と隔てられた状態で配列として扱っているが、
	// コードからの戻り値時点ではその区別を付けられない。
	// JavaScript 上では配列全体を式に組み込めない性質を利用して、
	// 戻り値の配列が式内に位置していればグループ化演算子、そうでなければ配列として振舞っている。
	
);
```
## `$[ ... ]` 参照演算子
　文字列を `$[` `]` で囲むと、その内側の文字列全体を第二引数 *assigned* のプロパティ名として、その名前のプロパティが存在していれば、その値で置換します。括弧内の文字列は空白も含めすべてプロパティ名として扱われる点に注意してください。文字列に一致する名前のプロパティが存在しない場合の値は undefined で、それがそのまま評価されれば空の文字列になります。参照演算子は評価演算子同様、任意の場所で使えます。

　空の文字列を指定すると、strings の第二引数 *assigned* に型 object 以外の値を指定した際に、その値で作成されるプロパティを取得できます。
```javascript
console.log(
	strings("$[sample]", { sample: 0 }), // [ '0' ]
	strings("$[サンプル]"), // [ '' ]
	strings("$[]", 0) // [ '0' ]
);
```
## `[ ... ]` 関数演算子
　`[` `]` で囲まれた文字列は、定義された関数のパラメーターとして使われ、その実行結果を基に文字列を生成します。
### パラメーターの構造とパターン
+ [関数名=プロパティ名:オプション:引数]
+ [関数名:オプション:引数]
+ [関数名:引数]

　パラメーターは左からヘッダー部、オプション部、ボディー部の三つに大別されます。この内、オプション部は省略可能です。各部はそれぞれコロン `:` ないしセミコロン `;` で隔てられますが、`;` はヘッダー部とそれ以外を隔てる時にのみ使用できます。後述しますが、`;` で隔てた際は、`:` で隔てた時とは挙動が変化する点にも注意してください。

### ヘッダー部
　ヘッダー部には関数名を指定します。関数名に続けて代入記号 `=` と、その後に任意の文字列を指定すると、その文字列を strings の第二引数 *assigned* のプロパティ名として、関数の実行結果を、その値として保存します。これら各要素間の空白は許容されかつ解析時には無視されます。

　ヘッダー部と他の部を隔てる記号は、通常は `:` を指定しますが、`;` を指定すると、関数の実行結果の戻り値への反映を抑制します。つまり、関数の実行結果はそのままでは戻り値に含まれません。抑制された出力は、参照演算子 `$[ ... ]` や、式中の識別子を通じて、他の関数処理などに反映させることができます。
```javascript
console.log(
	
	strings("[:0]"),                         // [ "0" ]
	strings("[;0]"),                         // [ "" ]
	// ヘッダー部をセミコロン ; で区切ると、出力は抑制される。
	
	strings("[=suppressed;0]$[suppressed]"), // [ "0" ]
	// 抑制した出力は、参照演算子や識別子を通じて任意の場所で利用できる。
	
	strings("[=;0]$[]")	                  // [ "0" ]
	// プロパティ名を指定しない場合、暗黙的にプロパティ StringsExpression.anonAssignKey の値に設定される。
	// このプロパティは $[] を通じて参照する。
	
);
```
　実際のところ、関数演算子には、ひとつ以上の `:` ないし `;` が必須で、関数演算子の最小構成は `[]` ではなく、`[:]` になります。

### オプション部
　ヘッダー部とボディー部の間には任意でオプション部を設定できます。オプション部は、ヘッダー部の区切り文字（`:`, `;`）のあとに記述し、ボディー部との間は常に `:` で隔てます。オプション部には任意の数のオプションを指定します。

　オプションは、関数の戻り値を操作します。オプションの指定方法は二通りあり、引数を伴わないオプションはオプション名を文字列で指定、引数を伴う際は、オプション名に続けてグループ化演算子 `( ... )` を使って引数を指定します。引数間はカンマ演算子 `,` で区切ります。オプション間はホワイトスペースかタブで区切ります。

　オプションは現状では以下のものを指定できます。

#### `echo([counts][, separator])`
　関数の戻り値を第一引数 *counts* で指定した回数だけ複製します。*counts* には非負整数を指定します。負の値を指定した場合は 0 に、非数値を指定した場合は 1 が使われます。第二引数 *separator* に任意の文字列を指定すると、複製した戻り値の間に separator を挟みます。このオプションは、関数 `^` と同等です。複製したい値が任意の関数の戻り値に限定される場合、このオプションを使った方が明示的になります。

　関数 `^` も同様ですが、*counts* に安易に大きな数値を指定すると、戻り値によってはコンピューターのリソースを消費し尽くす点に注意してください。戻り値の大きさは、関数の実行結果の要素数を *counts* でべき乗すると事前に確かめられます。
```javascript
console.log(
	
	strings("[:echo(3, '・'): 'い', 'ろ', 'は']"),
	// この関数の戻り値は、オプションなしだと三つの文字列 [ "い", "ろ", "は" ] を生成する。
	// 上記のオプションを付けると、すべての要素をそれぞれ三回繰り返すため、
	// 3 ^ 3 で、全 27 通りの文字列を生成することになる。
	
	strings("[: 'い', 'ろ', 'は']・[: 'い', 'ろ', 'は']・[: 'い', 'ろ', 'は']")
	// 同じ戻り値を得られる構文を echo を使わずに記述すると上記のようになる。
	
);
```

### ボディー部
　ボディー部には、関数に与える引数を指定します。引数が複数ある場合は、引数間をカンマ演算子 `,` で区切ります。

　引数では式が使えます。式中では各種演算子や識別子を指定することができます。

以下、執筆中。

　関数名区間ないしオプション区間に続く引数区間でも同様に各引数間はコンマ , で区切ります。

　引数は、原則として式として評価されます。式は値の型判定と四則演算、assigned 内のプロパティ名を示す識別子の使用に対応しています。値に使える型は string, number, boolean, undefined に対応しており、他に null 相当の値も指定できます。string はシングルクォーテーションで ' で囲みます。引数に string を与える場合、strings の第一引数 string に与える文字列はダブルクォーテーション " で囲むことが推奨されます。でなければ、引数の文字列を囲むシングルクォーテーション ' は、通常の JavaScript の仕様に則って単一のバックスラッシュ \\ でエスケープする必要があります。number は十進法表記にのみ対応します。

　boolean は true を shin、false を gi で表します。これらは true, false をそれぞれ日本語にした真、偽に由来します。undefined は hu、null は nai で、これらも日本語に由来します。こうした命名は興味本位以上の理由を持たないため、変更の可能性は常に存在します。（hu は、「不」に由来しますが、fu の方が打ち易く、日本語話者には直感的かもしれません。ここでは if と区別し易くするため hu にしています）

　上記の仕様を持つ式を評価する過程で、関数 eval などの JavaScript 内部の構文解析を経ない点に留意してください。strings では実装されていない JavaScript 上の仕様を式に含めると、シンタックスエラーを起こします。

　式が演算子を含まない、単一の値であれば、その値に再帰構文や Array などの任意の型の値を指定できます。ただし、それらを引数として想定した関数に与えないと、シンタックスエラーを起こすでしょう。

<!--# 0 と 1 の 8 次元座標
```javascript
console.log(...strings("[^:8,',',<[+:0,1,1]>]")); // その1
console.log(...strings("[+:echo(8,','):0,1,1]")); // その2
```-->