# 注意
以下の説明は**すべて**過去の仕様について述べています。アーカイブ用で、読む必要は一切ありません。

# 使用例
```javascript
import strings from './strings.js';

console.log('Into the Dimension 8:', ...strings("([0,1,1]^8,',')"));
```


# TODO (深刻度順)
+ 構文構造 v2
```
"[(構文名)((=変数名(;|:))(オプション);)((引数|<Stringes.get引数(\|...)>), ...)]"
```
+ 全体的にエラーハンドリングが欠如しすぎている。
+ undefined を hu(=不)、null を nai にする。
+ (...) の再帰をほぼ検証していないため動作確認。
+ 特定の文字列が存在した場合、全体を文字列ではなく生の値で返す。
+ 各構文に除外リスト的なものを指定できるようにする。

# ✔️ DONE
+ 引数に undefined 的なものを指定できるようにする。
> 検証は杜撰。引数に undefined を指定したい場合は nai を指定する。[0,5,nai] は、第三引数が Composer.increase の既定値の 1 で補われ [0,5,1] になるため、戻り値は [ '0', '1', '2', '3', '4', '5' ] になる。nai は日本語の「無い」に由来するが、これは null を意識した以上の意味はなく、より必然性の高い語句があればそれに代替すべき。そもそも null !== undefined であるため不適切。
+ dom で外部 HTML を読み込み。（同一オリジン限定）
> 最低限の実用性を持たせようとすると現状でも引数が足りない（特に iframe のサイズを指定できるようにすべき）が、一方で一度に指定するには引数の数が多すぎるので、なんらかの方法でまとめられる引数はまとめて指定できるようにしないと可読性が落ち、記述するためのコストも上がり続ける。
+ すべての構文で括弧内接頭辞 / に対応。（詳細は :; ;; を参照）

# 目次
- [概要](#概要)
- [構文](#構文)
  * [構文構造](#構文構造)
  * ['...'](#'...')
  * [\[...\]](#\[...\])
  * [\<...\>](#\<...\>)
  * [(...)](#(...))
  * [:;, ;;](#:;, ;;)
    + [>=](#>=)
    + [<=](#<=)
  * [\*...\*](#\[...\])
  * [`...`](#\[...\])
  * [{...}](#\[...\])
  * [^...^](#\[...\])
  * [\~...\~](#\[...\])
- [動作確認用](#動作確認用)

# 概要
構文に基づいて文字列を生成する。構文にエラーハンドリング等は一切実装しておらず、堅牢性はない。エスケープは \\\\ で行なう。\\\\(=\\) を文字列として使う場合は、\\\\\\\\ になる。' を使う構文があるため、解析の対象文字列は " で囲うことを推奨。

# 構文

## 構文構造
	"構文開始文字[[ラベル名](:||;)[フラグ];]([再帰URL||][[[引数], 引数], ...]||[[[再帰]|再帰]|...])構文終了文字"

## '...'
シングルクォーテーションで囲まれた値は常に文字列を示す。文字列中では構文に使う文字を含め、クォーテーション(",')以外の任意の文字列を通常の JavaScript の文字列と同様 \\ なしで指定できる。エスケープする際は " は \\、' は \\\\ で行なう。

## \[...\]
左から順に 開始値,終了値,増加値,字詰め文字,桁数(正の値の場合先頭方向、負の値の場合末尾方向へ字詰めする) を記す。開始値、終了値には文字列も指定できる。その場合、増加値は開始値のコードポイントに加算される。例えば ['a','c',1] は 'a' 'b' 'c' を生成する。終了値が開始値より小さい場合、値は負の方向へ進行する。増加値は負の値を受け付けるが、値は常に自然数に変換される。一方で、負の値を指定した場合、仮に出力の末尾が増加値を超えた場合、通常だとその値は出力に含まれないが、末尾を常に終了値で補完する。この構文は Composer.increase の短絡表現のため、より詳細な説明が必要な場合は同メソッドのコメントを参照できる。

## \<...\>
第一引数の文字列をセレクターとして、指定されたドキュメント（既定ではスクリプトの実行元）内でそれに一致するすべての要素を選択し、それらから第二引数に指定された属性名ないしプロパティ名の値で文字列を生成する。第二引数を省略した場合、選択要素の textContent に置き換わる。第二引数に指定した文字列の先頭に . を付けると、属性名ではなくプロパティ名として認識し、'.dataset.dummy' のように、以後 .プロパティ名 を連結してネストするプロパティにアクセスできる。第三引数に正規表現を示す文字列を指定すると、その取得した値からその正規表現に一致する部分を抽出して文字列を生成する。この正規表現は指定段階では文字列であるため、メタ文字に含まれる \ は \\ としなければならない。第一引数の前に | を置いて、その左側に URL に相当する文字列を指定すると、その URL が示す HTML 文書内から要素の値を取得する。URL には絶対、相対パスを指定できるが、絶対パスを指定しても同一オリジンポリシーによりリソースが取得できることはないと思われる。相対パスを指定した場合、このスクリプトの実行パスを基点として、パスが示す同一サーバー内のリソースの取得を試みる。外部リソースの取り扱いにまつわる様々な制約を回避するために、取得したリソースは実行パス上に追加される \<iframe\> でインラインで展開される。これは、リソースが実行元とは異なる階層に存在していて、リソース内に相対パスが含まれる場合、リソースが正常に動作しないことを意味する。この構文が取得するのは画像などのメディアではなくドキュメント構造上に存在する情報なので、リソースが静的な HTML であれば問題が表面化しないが、外部リソースの JavaScript などで動的に情報を読み込むページの場合、求める情報を得ることはできないだろう。このように、HTML や JavaScript に課せられた制約のため、提供される機能が実用に至るケースはそれほど多くないか、ほとんどないと思われる。URL に指定した文字列は、Strings.prototype.get で再帰的に解析される。これは例えば機械的に生成された規則的な URL 上のページの情報にアクセスする際に有用となるだろう。URL を指定する時、URL が不特定多数である場合、第四引数に URL にアクセスする間隔をミリ秒で指定できる例えば URL が 0.html, 1.html で、第四引数が 500 の場合、0.html を取得後、0.5 秒後に 1.html への要求を開始する。自然数以外の値、例えば -1 を指定すると、すべての URL に同時平行してアクセスする。これは URL の数によってはサーバーに損害を与えかねないので、ローカルサーバーに対してなどに対してでなければ決して推奨されない。この値は、既定では 1000 ミリ秒に設定される。第五引数はリクエストのタイムアウトを待つ時間で、ミリ秒で指定する。設定した時間内にリクエストが完了しなければ、リクエストは強制的に中断され、その URL が示す情報は未指定として扱われる。既定では 30000 ミリ秒に設定される。

## (...)
括弧内のコンマで区切られた値で分岐させる。値間は | で区切る。この中の値は、Strings.get を再帰して処理される。そのため、文字列の指定は ' で囲わずに行なう必要がある。そして再帰されるため、任意の構文を必要に応じて使用することができる。再帰前にラベル付けした値も再帰先から参照できる。（ただし再帰先で同名のラベルを付けた場合、再帰前の同名ラベルはそのラベルの値で上書きされる）なお、この構文そのものには (label:=;a|b) のようなラベル付けや挙動の指定はできない。この構文で生成する値を再利用するなどしたい場合は (\~label:;'a'\~|b)\*label\* などとする

## :;, ;;
[labeled:; ...] のように、各括弧内の行頭から :; ないし ;; までの間はラベルとして認識される。ラベルを :; で閉じた場合、その括弧の値はその場で展開されると同時にラベル付けされて記録もされる。ラベルを ;; で閉じた場合、その括弧の値はラベル付けされて後方参照が可能になるが、その場での展開はされない。ラベル付けされた値を再利用するには、それより後方で下記構文 *...* を使う。なお、実際には、すべての構文にラベルが暗黙に割り当てられる。明示的にラベルを指定していない構文に対しては、ただの文字列も含め、全体の左から数えたその構文の位置が便宜的なラベルになる。例えば "a(b|c)d\*1\*\*2\*"の場合、生成される文字列は [ 'abdbd', 'abdcd', 'acdbd', 'acdcd' ] である。この出力は、明示的にラベル付けした "a(1:;b|c)(2:;d)\*1\*\*2\*" の出力と等価である。:; ;; いずれの場合も、\<label:\>=; ...\> のように、二つの記号の間に特定の文字列(オプション)を指定して構文の挙動を変更することができる。オプションは空白で区切り複数指定可能だが、現状はいずれのオプションも排他関係にある。(実際に行なうかどうかはともかく、破壊的な改修を伴う変更の余地がある。例えば引数を受け付けるオプションを指定できれば柔軟性が向上する。)

+ ### >=
> 構文によって生成された文字列が前方までに生成された文字列より少ない場合、前方の数に達するまで生成された文字列を繰り返して補われる。例えば "['a','c',1][:>=;'a','b',1]" は 'aa', 'bb', 'ca' を生成する。一方、構文の生成文字列が前方までの生成文字列を超過する場合、構文の生成文字列は前方までのそれの数に切り詰められる。['a','c',1][:>=;'a','d',1] は 'aa', 'bb', 'cc' を生成する。
+ ### <=
> \>= の逆を行なう。"['a','c',1][:<=;'a','b',1]" は [ 'aa', 'bb' ] を生成する。"['a','c',1][:<=;'a','d',1]" は [ 'aa', 'bb', 'cc', 'ad' ] を生成する。

## \*...\*
ラベル名をアスタリスクで囲んだものは、そのラベルの値で代替される。(...) などでネストした時も、ネスト先から上位のラベルを参照できるが、若干同一階層間で参照した時と挙動が異なる。同一階層の時、参照する値は、参照元で生成した実際の値をそのまま再利用する。つまり生成処理は繰り返されない。一方、異なる階層間で参照すると、生成後の値を参照するのではなく、生成前の記述子を参照し、それを実際の生成処理に用いる。つまりまったく同じ値を作成する処理を繰り返す。それ以外にも違いがある可能性はゼロではないが今のところ未確認。以下は廃止。代替は \*:=;...\*この構文を使用する時、ラベル名の先頭に / を付けると、ラベル付けされた値の適用方法を切り替える。/ なしの場合、値は それ以前に生成されたすべての文字列 \* ラベル付けされた値が持つ文字列の数 分生成される。/ を付けた場合、ラベル付けされた値は単純にそれまで生成された文字列に結合され、ラベル付けされた値の数 < それまでに生成された文字列の数 だった場合、ラベル付けされた値は不足に達した時点でラベル付けされた値内を周回して不足分を補う。以下は動作モードの違いによる出力の例。labeled = [ 0, 1, 2 ], strings = [ 'a', 'b', 'c', 'd', 'e' ]Strings.get("[labeled;;0,2,1]['a','e',1]\*labeled\*");	// [ 'a0', 'a1, 'a2', 'b0', 'b1', 'b2', 'c0', 'c1, 'c2', 'd0', 'd1, 'd2', 'e0', 'e1, 'e2' ]Strings.get("[labeled;;0,2,1]['a','e',1]\*/labeled\*");	// [ 'a0', 'b1, 'c2', 'd0', 'e1' ]

## `...`
括弧中の文字列を JavaScript として実行し、return によって返された値を戻り値として使う。引数 labeled に、ラベルを付けた値をプロパティに示す Object が与えられる。仕様で補え切れない状況に対応するための応急処置的な使用を想定しており、可読性を著しく落とす。この括弧中でのテンプレート文字列の使用は現状非対応。

## {...}
値間を , で区切り、最初の値を実行主体、次の値(文字列)を(JavaScript APIの)メソッド名、以降をそのメソッドの引数として、指定のメソッドを実行する。直接値を指定する場合、数値か文字列しか指定できないが、他の構文、例えば `...` と組み合わせることで間接的に任意の値を指定できる。値にはラベルを変数的に指定でき、その際はラベルの文字列を \* で囲む必要はない。ただし、この場合、指定するラベルは JavaScript の識別子と同じ命名規則に従っていなければならない。https://developer.mozilla.org/ja/docs/Glossary/Identifier
## ^...^
直後の構文ないし文字列を指定に従って繰り返す。以下の引数を取る。
+ ### loopCount (optional)
> 任意の自然数で、| で区切られた右側の文字列を繰り返す回数を指定する。
+ ### separator (optional)
> ' で囲った任意の文字列で、| で区切られた右側の文字列を繰り返す時の区切り文字になる。
+ ### strings
> 繰り返す文字列を指定する。上記の引数とは | で区切る。指定された文字列は ParseHelper.prototype.get の第一引数として再帰して解析される。重要な点として、この文字列は ' で囲う必要はない。' で囲うと構文を含んでいても単一の文字列として解釈される。また、文字列に構文 (...) を使用する場合、同構文内の区切り文字 | は \ でエスケープしなければ認識されない。文字列中にプレースホルダー $i $I $l が使える。$i は 0 から開始する現在のループ回数、$I は 1 から開始する同回数、$l は loopCount に置換される。仮にこれらのプレースホルダーを文字列として使う場合は \\$i などとする。プレースホルダーは構文内外問わず任意に指定できる。
指定は "^2,','|a^" のように行なう。この出力は [ 'a,a' ] である。
指定次第で予期しない巨大な出力を生成する点に注意が必要。
（一方、リソース不足エラーにより思ったより巨大なデータを得られない点にも気付くかもしれない）

## \~...\~
この構文内の文字列を式として評価し、その結果を文字列にする。分岐などは行なわない。対応しているのは四則演算のみ。^...^ でプレースホルダーを使って文字列を生成したり、(\~label:;'a'\~|b)\*label\* などとして分岐する文字列をラベル化するなどの使い方が考えられる。便宜的な実装で構文記号含め変更の必要が強い。特に構文の優先順位の必然性など確認が不足している。

エスケープも含め、上記の構文文字は任意の文字に変更しようと思えばできなくはないが、一切動作検証していないので強く推奨しない。

# 動作確認用
```javascript
Strings.get("a`return '0'+1;;`[label:0,5,1,5,'_',2,'_']<'#id[id=\"sample\"]', 'textContent'>(a|b)\*label\*");
```